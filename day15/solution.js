let program = [3,1033,1008,1033,1,1032,1005,1032,31,1008,1033,2,1032,1005,1032,58,1008,1033,3,1032,1005,1032,81,1008,1033,4,1032,1005,1032,104,99,1002,1034,1,1039,1002,1036,1,1041,1001,1035,-1,1040,1008,1038,0,1043,102,-1,1043,1032,1,1037,1032,1042,1106,0,124,1001,1034,0,1039,1002,1036,1,1041,1001,1035,1,1040,1008,1038,0,1043,1,1037,1038,1042,1106,0,124,1001,1034,-1,1039,1008,1036,0,1041,1002,1035,1,1040,1001,1038,0,1043,101,0,1037,1042,1105,1,124,1001,1034,1,1039,1008,1036,0,1041,102,1,1035,1040,1001,1038,0,1043,101,0,1037,1042,1006,1039,217,1006,1040,217,1008,1039,40,1032,1005,1032,217,1008,1040,40,1032,1005,1032,217,1008,1039,39,1032,1006,1032,165,1008,1040,3,1032,1006,1032,165,1102,1,2,1044,1106,0,224,2,1041,1043,1032,1006,1032,179,1102,1,1,1044,1106,0,224,1,1041,1043,1032,1006,1032,217,1,1042,1043,1032,1001,1032,-1,1032,1002,1032,39,1032,1,1032,1039,1032,101,-1,1032,1032,101,252,1032,211,1007,0,59,1044,1105,1,224,1102,1,0,1044,1105,1,224,1006,1044,247,101,0,1039,1034,1001,1040,0,1035,101,0,1041,1036,1002,1043,1,1038,1002,1042,1,1037,4,1044,1105,1,0,93,27,71,56,88,17,30,78,5,57,79,56,3,82,62,58,16,2,21,89,95,33,12,32,90,12,7,76,83,31,8,13,27,89,60,33,7,40,22,50,8,63,35,45,57,94,81,4,65,33,47,73,28,98,11,70,95,17,82,39,19,73,62,56,80,85,23,91,39,86,91,82,50,37,86,4,90,83,8,65,56,63,15,99,51,3,60,60,77,58,90,82,5,52,14,87,37,74,85,43,17,61,91,35,31,81,19,12,34,54,9,66,34,69,67,21,4,14,87,22,76,26,82,79,4,69,48,73,8,73,57,61,83,23,83,60,3,41,75,67,53,44,91,27,52,84,66,13,65,95,81,83,30,26,60,12,33,92,81,46,78,25,13,72,87,26,63,57,35,2,60,96,63,26,2,76,95,21,38,60,5,79,86,89,47,42,12,91,30,52,69,55,67,73,47,44,5,86,8,52,69,81,23,70,3,38,41,89,88,58,41,9,96,27,67,21,14,68,67,35,84,23,20,91,63,47,75,34,70,57,13,54,82,33,61,27,97,88,46,44,56,74,14,5,96,71,16,40,86,61,84,41,81,81,16,88,51,41,96,76,28,97,44,41,65,87,50,73,58,71,46,73,51,43,18,46,99,74,65,9,89,3,77,22,34,93,94,39,54,96,12,35,62,87,56,69,64,9,34,91,64,71,28,10,94,1,96,20,67,92,39,37,26,79,68,16,76,57,83,92,46,75,99,26,64,39,72,65,37,93,65,5,53,62,36,13,97,14,38,85,33,76,56,99,29,64,84,28,19,91,92,55,33,88,32,70,38,53,76,1,76,35,26,75,18,18,7,88,19,53,65,22,91,20,85,15,13,72,82,13,31,75,62,68,4,56,91,89,56,10,46,63,7,74,50,15,85,87,64,77,12,95,10,66,77,51,6,61,75,91,75,85,61,78,4,97,99,4,90,34,89,44,44,68,89,30,20,70,24,22,81,22,77,61,33,89,2,11,75,50,85,13,43,56,78,73,49,27,38,78,56,90,17,94,72,51,5,55,67,32,19,81,81,45,83,18,96,33,75,53,4,29,87,80,33,57,78,80,43,68,57,71,83,10,18,98,70,36,61,31,73,33,69,24,78,76,43,88,96,16,14,91,43,66,15,98,44,48,68,57,72,48,49,89,62,31,55,83,68,86,97,16,25,87,13,74,40,82,43,48,85,40,45,72,33,60,84,4,47,96,19,92,75,73,46,6,69,4,81,98,89,48,55,89,24,64,31,47,50,93,72,47,72,36,79,7,24,66,60,65,18,81,93,40,37,36,62,94,48,8,77,21,82,22,65,20,46,85,47,52,70,55,74,19,65,15,72,81,57,67,46,94,21,16,94,84,36,43,62,82,48,47,79,5,96,39,58,85,80,31,7,98,23,69,22,99,37,69,35,66,36,70,3,69,47,6,64,38,69,42,57,91,89,21,89,13,42,78,24,44,79,74,65,63,85,10,50,71,94,26,78,55,5,26,71,46,20,83,96,51,87,2,99,83,5,38,86,8,13,94,61,93,39,67,23,60,74,87,57,30,72,23,19,95,57,93,83,58,34,83,35,4,47,81,88,24,87,34,93,79,70,18,24,73,98,76,77,24,93,18,66,56,87,25,29,7,7,97,40,61,56,96,96,1,42,21,92,73,11,10,97,69,58,93,2,82,27,96,7,84,44,67,57,63,13,79,56,72,34,89,26,94,24,86,99,71,73,98,26,89,10,98,5,64,70,85,32,61,35,67,0,0,21,21,1,10,1,0,0,0,0,0,0];
let programpointer = 0;
let outs = 1;
let inputs = [1];
let relativebase = 0;

let board = new Map();
let spacesthatneedo2 =new Map();
let curx = 0;
let cury = 0;
let tryx = curx;
let tryy = cury;
let minx = 0;
let maxx = 0;
let miny = 0;
let maxy = 0;
let o2loc = null;

let cursq = buildsquare(curx, cury, "O");
let locstovisit = [];
let choices = [];
let moves = [];
board.set(cursq.key, cursq);
locstovisit.push(cursq);

//need to find the oxygen unit
while(locstovisit.length != 0 || moves.length == 0) {
    //every time we are at a space, look at all adjacent spaces
    locstovisit.pop();
    cursq = board.get(`${curx},${cury}`);
    if(!cursq.mapped) {
        //maps it
        //N
        if(!board.has(`${curx},${cury+1}`)){
            let result = doit(1);
            let newsq = buildsquare(curx, cury+1, result);
            board.set(newsq.key, newsq);
            if(newsq.type !== 0) {
                locstovisit.push(newsq);
                doit(2);
            }
        }
        //S
        if(!board.has(`${curx},${cury-1}`)){
            let result = doit(2);
            let newsq = buildsquare(curx, cury-1, result);
            board.set(newsq.key, newsq);
            if(newsq.type !== 0) {
                locstovisit.push(newsq);
                doit(1);
            }
        }
        //W
        if(!board.has(`${curx-1},${cury}`)){
            let result = doit(3);   
            let newsq = buildsquare(curx-1, cury, result);
            board.set(newsq.key, newsq);
            if(newsq.type !== 0) {
                locstovisit.push(newsq);
                doit(4);
            }
        }
        //E
        if(!board.has(`${curx+1},${cury}`)){            
            let result = doit(4);   
            let newsq = buildsquare(curx+1, cury, result);
            board.set(newsq.key, newsq);
            if(newsq.type !== 0) {
                locstovisit.push(newsq);
                doit(3);
            }
        }
        cursq.mapped = true;
        console.log(`Mapped ${cursq.x},${cursq.y}`);
    }
    //actually move now
    //let sqtomoveto = locstovisit[locstovisit.length-1];
    let sqtomoveto = null;
    if(locstovisit.length === 0) break;
    else sqtomoveto = locstovisit[locstovisit.length-1];
    //need to pop and move until we hit one of our unmapped squares
    //check if its in our range

    while(!isinrange(sqtomoveto)) {
        let previous = moves.pop();
        let dir = getdirectionbackup(previous);
        console.log(`trying to get to ${sqtomoveto.x}, ${sqtomoveto.y} from ${curx},${cury} dir: ${previous}`);
        let result = doit(dir);
        if (result === "HALT") {
            console.log(`Uh oh: trying to get to ${sqtomoveto.x}, ${sqtomoveto.y} from ${curx},${cury} dir: ${previous}`);
            break;
        }
        else move();
        console.log(`Moved to ${curx},${cury}`);
    }
    let result = doit(getdirectionwithaudit(sqtomoveto));

    if(miny > tryy) miny = tryy;
    if(maxy < tryy) maxy = tryy;
    if(minx > tryx) minx = tryx;
    if(maxx < tryx) maxx = tryx;
    
    if(result === "HALT") break;
    if(result === 0) {
        //hit a wall
        console.log("Should never happen");
        reset();
    }
    else if(result === 1) {
        move();
        spacesthatneedo2.set(`${curx},${cury}`, {"x":curx,"y":cury});
    } else {
        //Unit found!
        o2loc = sqtomoveto;
        spacesthatneedo2.delete(`${o2loc.x},${o2loc.y}`);
        move();
    }
    console.log(`Moved to ${curx},${cury}`);
}

//at this point i have the entire ship mapped out - need to calculate the distance from the 02 sensor for every point and take the max
function getdistancesfromo2() {
    let start = o2loc;
    //fill in all adjacents with O2 and track valid moves
    let spacestofillwithair = [];
    let maxdis = 1;
    let depth = 1;
    //find valid spaces adjacent
    //N
    if(spacesthatneedo2.has(`${o2loc.x},${o2loc.y+1}`)){
        spacestofillwithair.push({"x":o2loc.x, "y":o2loc.y+1, "distance": depth, "key": `${o2loc.x},${o2loc.y+1}`});
    }
    //S
    if(spacesthatneedo2.has(`${o2loc.x},${o2loc.y-1}`)){
        spacestofillwithair.push({"x":o2loc.x, "y":o2loc.y-1, "distance": depth, "key": `${o2loc.x},${o2loc.y-1}`});
    }
    //W
    if(spacesthatneedo2.has(`${o2loc.x-1},${o2loc.y}`)){
        spacestofillwithair.push({"x":o2loc.x-1, "y":o2loc.y, "distance": depth, "key": `${o2loc.x-1},${o2loc.y}`});
    }
    //E
    if(spacesthatneedo2.has(`${o2loc.x+1},${o2loc.y}`)){
        spacestofillwithair.push({"x":o2loc.x+1, "y":o2loc.y, "distance": depth, "key": `${o2loc.x+1},${o2loc.y}`});
    }
    while(spacestofillwithair.length > 0) {
        //pop, make sure it still needs it, and fill it
        let roomtofill = spacestofillwithair.pop();
        if(spacesthatneedo2.has(roomtofill.key)){
            if(roomtofill.distance > maxdis) maxdis = roomtofill.distance;
            let newdepth = roomtofill.distance + 1;
            spacesthatneedo2.delete(roomtofill.key);
            //N
            if(spacesthatneedo2.has(`${roomtofill.x},${roomtofill.y+1}`)){
                spacestofillwithair.push({"x":roomtofill.x, "y":roomtofill.y+1, "distance": newdepth, "key": `${roomtofill.x},${roomtofill.y+1}`});
            }
            //S
            if(spacesthatneedo2.has(`${roomtofill.x},${roomtofill.y-1}`)){
                spacestofillwithair.push({"x":roomtofill.x, "y":roomtofill.y-1, "distance": newdepth, "key": `${roomtofill.x},${roomtofill.y-1}`});
            }
            //W
            if(spacesthatneedo2.has(`${roomtofill.x-1},${roomtofill.y}`)){
                spacestofillwithair.push({"x":roomtofill.x-1, "y":roomtofill.y, "distance": newdepth, "key": `${roomtofill.x-1},${roomtofill.y}`});
            }
            //E
            if(spacesthatneedo2.has(`${roomtofill.x+1},${roomtofill.y}`)){
                spacestofillwithair.push({"x":roomtofill.x+1, "y":roomtofill.y, "distance": newdepth, "key": `${roomtofill.x+1},${roomtofill.y}`});
            }
        }
    }
    console.log(maxdis);
}

printboard();
console.log(o2loc);
getdistancesfromo2();
//get minx,miny,maxx,maxy;

function isinrange(square) {
    if(Math.abs(square.x - curx) > 1) return false;
    if(Math.abs(square.y - cury) > 1) return false;
    if(Math.abs(square.y - cury) === 1 && Math.abs(square.x - curx) === 1) return false;
    return true;
}

function doit(dir) {
    //move movement into here at some point
    let output = runprog(program, [dir], programpointer, outs, relativebase);
    programpointer = output[0].pointer;
    relativebase = output[0].relativebase;
    let result = output[0].output;
    return result;
}

function printboard() {
    let str = "";
    for(var i = maxy+1; i >= miny-1; i--){ 
        str += "\r\n"
        for(var j = minx-1; j <= maxx+1; j++) {
            let sq = board.get(`${j},${i}`);
            let chartoprint = " ";
            if(board.has(`${j},${i}`)){
                switch(sq.type) {
                    case 0: 
                        chartoprint = "#";
                        break;
                    case 1:
                        chartoprint = ".";
                        break;
                    case 2:
                        chartoprint = "X";
                        break;
                }
            }
            str += chartoprint;
        }
    }
    console.log(str);
}

function move() {
    curx = tryx;
    cury = tryy;
    
}

function reset() {
    tryx = curx;
    tryy = cury;
}

function getdirectionbackup(odir) {
    switch(odir) {
        case 1:
            tryy--;
            return 2;
        case 2:
            tryy++;
            return 1;
        case 3:
            tryx++;
            return 4;
        case 4:
            tryx--;
            return 3;
    }
}

function getdirectionwithaudit(destination) {
    if(destination.y > cury) {
        tryy++;
        moves.push(1);
        return 1;
    }
    if(destination.y < cury) {
        tryy--;
        moves.push(2);
        return 2;
    }
    if(destination.x < curx) {
        tryx--;
        moves.push(3);
        return 3;
    }
    if(destination.x > curx) {
        tryx++;
        moves.push(4);
        return 4;
    }
    // if(!board.has(`${curx},${cury+1}`)) {
    //     tryy++;
    //     return 1;
    // }
    // if(!board.has(`${curx+1},${cury}`)) {
    //     tryx++;
    //     return 4;
    // }
    // if(!board.has(`${curx-1},${cury}`)) {
    //     tryx--;
    //     return 3;
    // }
    // if(!board.has(`${curx},${cury-1}`)) {
    //     tryy--;
    //     return 2;
    // }
}

function buildsquare(x,y,type) {
    return {"x":x, "y": y, "type":type, "key": `${x},${y}`, "mapped": false, "o2": false};
}

function runprog(program, inputs, programpointer, outs, relativebase) {
    let inputpointer = 0;
    let terminate = false;
    //let relativebase = 0;
    let loops = 0;
    let rout = [];
    for(var i = programpointer; i < program.length && !terminate;) {
        //console.log(`${++loops}, ${i}`);
        let instruction = program[i].toString();
        //ABCDE - DE is 2 digit Opscode, C is mode of 1st param, B mode of 2nd param, A mode 3rd param
        //add 0's until it is 5 digits
        while(instruction.length !== 5) {
            instruction = "0" + instruction;
        }
        let opscode = parseInt(instruction.substring(3),10);
        let param1mode = parseInt(instruction.substring(2,3),10);
        let param2mode = parseInt(instruction.substring(1,2),10);
        let param3mode = parseInt(instruction.substring(0,1),10);
        
        switch(opscode) {
            case 1:
                //Opcode 1 adds together numbers read from two positions and stores the result in a third position
                //param1 = program[++i];
                param1 = accessinstruction(program, ++i);
                param1v = getvalue(param1mode, param1, program, relativebase);
                param2 = accessinstruction(program, ++i);
                param2v = getvalue(param2mode, param2, program, relativebase);
                sum = param1v + param2v;
                param3 = accessinstruction(program, ++i);;
                if(param3mode === 1) {
                    if(param3 >= program.length) growprogram(program, param3);
                    program[param3] = sum;
                }
                else program[getindex(param3mode, param3, program, relativebase)] = sum;
                i++;
                break;
            case 2:
                //Opcode 2 works exactly like opcode 1, except it multiplies the two inputs instead of adding them
                param1 = accessinstruction(program, ++i);
                param1v = getvalue(param1mode, param1, program, relativebase);
                param2 = accessinstruction(program, ++i);
                param2v = getvalue(param2mode, param2, program, relativebase);
                product = param1v * param2v;
                param3 = accessinstruction(program, ++i);
                if(param3mode === 1) {
                    if(param3 >= program.length) growprogram(program, param3);
                    program[param3] = product;
                }
                else program[getindex(param3mode, param3, program, relativebase)] = product;
                i++;
                break;
            case 3:
                //Opcode 3 takes a single integer as input and saves it to the position given by its only parameter
                param1 = accessinstruction(program, ++i);
                switch(param1mode) {
                    case 0:
                        if(param1 >= program.length) growprogram(program, param1);
                        program[param1]  = inputs[inputpointer++];
                        break;
                    case 1:
                        break;
                    case 2:
                        if((relativebase + param1) >= program.length) growprogram(program, (relativebase + param1));
                        program[param1 + relativebase] = inputs[inputpointer++];
                        break;
                }
                i++;
                break;
            case 4:
                //Opcode 4 outputs the value of its only parameter
                param1 = program[++i];
                param1v = getvalue(param1mode, param1, program, relativebase);
                i++;
                //console.log({"output": param1v, "pointer": i});
                rout.push({"output": param1v, "pointer": i, "relativebase": relativebase});
                break;
            case 5:
                //if the first parameter is non-zero, it sets the instruction pointer to the value from the second parameter. Otherwise, it does nothing
                param1 = accessinstruction(program, ++i);
                param1v = getvalue(param1mode, param1, program, relativebase);
                param2 = accessinstruction(program, ++i);
                param2v = getvalue(param2mode, param2, program, relativebase);
                if(param1v !== 0) i = param2v;
                else i++;
                if(i >= program.length) growprogram(program, i);
                break;
            case 6:
                //if the first parameter is zero, it sets the instruction pointer to the value from the second parameter. Otherwise, it does nothing.
                param1 = accessinstruction(program, ++i);
                param1v = getvalue(param1mode, param1, program, relativebase);
                param2 = accessinstruction(program, ++i);
                param2v = getvalue(param2mode, param2, program, relativebase);
                if(param1v === 0) i = param2v;
                else i++;
                break;
            case 7:
                //if the first parameter is less than the second parameter, it stores 1 in the position given by the third parameter. Otherwise, it stores 0.
                param1 = accessinstruction(program, ++i);
                param1v = getvalue(param1mode, param1, program, relativebase);
                param2 = accessinstruction(program, ++i);
                param2v = getvalue(param2mode, param2, program, relativebase);
                param3 = accessinstruction(program, ++i);
                if(param3mode === 1) {
                    if(param3 >= program.length) growprogram(program, param3);
                    program[param3] = param1v < param2v ? 1 : 0;
                }
                else program[getindex(param3mode, param3, program, relativebase)] = param1v < param2v ? 1 : 0;
                i++;
                break;
            case 8:
                param1 = accessinstruction(program, ++i);
                param1v = getvalue(param1mode, param1, program, relativebase);
                param2 = accessinstruction(program, ++i);
                param2v = getvalue(param2mode, param2, program, relativebase);
                param3 = accessinstruction(program, ++i);
                if(param3mode === 1) {
                    if(param3 >= program.length) growprogram(program, param3);
                    program[param3] = param1v === param2v ? 1 : 0; 
                }
                else program[getindex(param3mode, param3, program, relativebase)] = param1v === param2v ? 1 : 0; 
                i++;
                break;
            case 9:
                //opcode 9 adjusts the relative base by the value of its only parameter. The relative base increases (or decreases, if the value is negative) by the value of the parameter.
                param1 = accessinstruction(program, ++i);
                
                switch(param1mode) {
                    case 0:
                        if(param1 >= program.length) growprogram(program, param1);
                        relativebase += program[param1];
                        break;
                    case 1:
                        relativebase += param1;
                        break;
                    case 2:
                        if((relativebase + param1) >= program.length) growprogram(program, (relativebase + param1));
                        relativebase += program[(relativebase + param1)];
                        break;
                }
                i++;
                break;
            case 99:
                terminate = true;
                console.log("HALT");
                rout.push({"output": "HALT", "pointer": i, "relativebase": relativebase});
                return rout;
                break;
        }
        if(rout.length === outs) return rout;

    }
    return {"output": "DONE", "pointer": 0};
}

function getvalue(parammode, param, program, relativebase) {
    switch(parammode) {
        case 0:
            if(param >= program.length) growprogram(program, param);
            return program[param];
        case 1:
            //if(param >= program.length) growprogram(program, param);
            return param;
        case 2:
            if((relativebase + param) >= program.length) growprogram(program, (relativebase + param));
            return program[relativebase + param];
    }
}

function accessinstruction(program, index) {
    if(index >= program.length) {
        growprogram(program, index);
    }
    return program[index];
}

function getindex(parammode, param, program, relativebase) {
    switch(parammode) {
        case 0:
            if(param >= program.length) growprogram(program, param);
            return param;
        case 1:
            if(param >= program.length) growprogram(program, param);
            return param;
        case 2:
            if((relativebase + param) >= program.length) growprogram(program, (relativebase + param));
            return relativebase + param;
    }
}

function growprogram(program, newindex) {
    for(var i = program.length; i <= newindex; i++) {
        program.push(0);
    }
}